// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ByteArray {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Used in database "blockLinks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoBlockLink {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "5")]
    pub blockhash: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "proto_block_link::Oneof1", tags = "1")]
    pub oneof1: ::core::option::Option<proto_block_link::Oneof1>,
    #[prost(oneof = "proto_block_link::Oneof2", tags = "2")]
    pub oneof2: ::core::option::Option<proto_block_link::Oneof2>,
    #[prost(oneof = "proto_block_link::Oneof3", tags = "3")]
    pub oneof3: ::core::option::Option<proto_block_link::Oneof3>,
    #[prost(oneof = "proto_block_link::Oneof4", tags = "4")]
    pub oneof4: ::core::option::Option<proto_block_link::Oneof4>,
}
/// Nested message and enum types in `ProtoBlockLink`.
pub mod proto_block_link {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof1 {
        #[prost(uint32, tag = "1")]
        Version(u32),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof2 {
        #[prost(uint64, tag = "2")]
        Index(u64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof3 {
        #[prost(uint64, tag = "3")]
        Dsindex(u64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof4 {
        #[prost(uint32, tag = "4")]
        Blocktype(u32),
    }
}
/// Used in databases "dsBlocks", "microBlocks", "txBlocks", "VCBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoBlockBase {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "1")]
    pub blockhash: ::prost::alloc::vec::Vec<u8>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub cosigs: ::core::option::Option<proto_block_base::CoSignatures>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint64, tag = "3")]
    pub timestamp: u64,
}
/// Nested message and enum types in `ProtoBlockBase`.
pub mod proto_block_base {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CoSignatures {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub cs1: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bool, repeated, tag = "2")]
        pub b1: ::prost::alloc::vec::Vec<bool>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "3")]
        pub cs2: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bool, repeated, tag = "4")]
        pub b2: ::prost::alloc::vec::Vec<bool>,
    }
}
/// Used in "dsBlockHeader", "microBlockHeader", "txBlockHeader", and "VCBlockHeader"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoBlockHeaderBase {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "2")]
    pub committeehash: ::prost::alloc::vec::Vec<u8>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "3")]
    pub prevhash: ::prost::alloc::vec::Vec<u8>,
}
/// Used in database "dsBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDsBlock {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<proto_ds_block::DsBlockHeader>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub blockbase: ::core::option::Option<ProtoBlockBase>,
}
/// Nested message and enum types in `ProtoDSBlock`.
pub mod proto_ds_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DsBlockHashSet {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "1")]
        pub shardinghash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "2")]
        pub reservedfield: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DsBlockHeader {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub blockheaderbase: ::core::option::Option<super::ProtoBlockHeaderBase>,
        /// Added in: v1.0, Deprecated in: N/A, Only LSB used
        #[prost(uint32, tag = "2")]
        pub dsdifficulty: u32,
        /// Added in: v1.0, Deprecated in: N/A, Only LSB used
        #[prost(uint32, tag = "3")]
        pub difficulty: u32,
        /// Added in: v1.0, Deprecated in: N/A, 32 bytes
        #[prost(bytes = "vec", tag = "4")]
        pub prevhash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "5")]
        pub leaderpubkey: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "8")]
        pub gasprice: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "9")]
        pub swinfo: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, repeated, tag = "10")]
        pub dswinners: ::prost::alloc::vec::Vec<ds_block_header::PowDsWinners>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "11")]
        pub hash: ::core::option::Option<DsBlockHashSet>,
        /// Added in: v2.0, Deprecated in: N/A
        #[prost(message, repeated, tag = "12")]
        pub dsremoved: ::prost::alloc::vec::Vec<super::ByteArray>,
        #[prost(message, repeated, tag = "13")]
        pub proposals: ::prost::alloc::vec::Vec<ds_block_header::Proposal>,
        #[prost(oneof = "ds_block_header::Oneof6", tags = "6")]
        pub oneof6: ::core::option::Option<ds_block_header::Oneof6>,
        #[prost(oneof = "ds_block_header::Oneof7", tags = "7")]
        pub oneof7: ::core::option::Option<ds_block_header::Oneof7>,
    }
    /// Nested message and enum types in `DSBlockHeader`.
    pub mod ds_block_header {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PowDsWinners {
            /// Added in: v1.0, Deprecated in: N/A
            #[prost(message, optional, tag = "1")]
            pub key: ::core::option::Option<super::super::ByteArray>,
            /// Added in: v1.0, Deprecated in: N/A
            #[prost(message, optional, tag = "2")]
            pub val: ::core::option::Option<super::super::ByteArray>,
        }
        /// Add new members here
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Vote {
            #[prost(uint32, tag = "1")]
            pub value: u32,
            #[prost(uint32, tag = "2")]
            pub count: u32,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Proposal {
            #[prost(uint32, tag = "1")]
            pub proposalid: u32,
            #[prost(message, repeated, tag = "2")]
            pub dsvotes: ::prost::alloc::vec::Vec<Vote>,
            #[prost(message, repeated, tag = "3")]
            pub minervotes: ::prost::alloc::vec::Vec<Vote>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof6 {
            #[prost(uint64, tag = "6")]
            Blocknum(u64),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof7 {
            #[prost(uint64, tag = "7")]
            Epochnum(u64),
        }
    }
}
/// Used in database "dsCommittee"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDsNode {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub pubkey: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub peer: ::core::option::Option<ByteArray>,
}
/// Used in database "dsCommittee"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDsCommittee {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, repeated, tag = "2")]
    pub dsnodes: ::prost::alloc::vec::Vec<ProtoDsNode>,
}
/// Used in database "microBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMicroBlock {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<proto_micro_block::MicroBlockHeader>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub tranhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "3")]
    pub blockbase: ::core::option::Option<ProtoBlockBase>,
}
/// Nested message and enum types in `ProtoMicroBlock`.
pub mod proto_micro_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MicroBlockHeader {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub blockheaderbase: ::core::option::Option<super::ProtoBlockHeaderBase>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(uint64, tag = "3")]
        pub gaslimit: u64,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "5")]
        pub rewards: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "6")]
        pub prevhash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "8")]
        pub txroothash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "10")]
        pub minerpubkey: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(uint64, tag = "11")]
        pub dsblocknum: u64,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "12")]
        pub statedeltahash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "13")]
        pub tranreceipthash: ::prost::alloc::vec::Vec<u8>,
        #[prost(oneof = "micro_block_header::Oneof2", tags = "2")]
        pub oneof2: ::core::option::Option<micro_block_header::Oneof2>,
        #[prost(oneof = "micro_block_header::Oneof4", tags = "4")]
        pub oneof4: ::core::option::Option<micro_block_header::Oneof4>,
        #[prost(oneof = "micro_block_header::Oneof7", tags = "7")]
        pub oneof7: ::core::option::Option<micro_block_header::Oneof7>,
        #[prost(oneof = "micro_block_header::Oneof9", tags = "9")]
        pub oneof9: ::core::option::Option<micro_block_header::Oneof9>,
    }
    /// Nested message and enum types in `MicroBlockHeader`.
    pub mod micro_block_header {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof2 {
            #[prost(uint32, tag = "2")]
            Shardid(u32),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof4 {
            #[prost(uint64, tag = "4")]
            Gasused(u64),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof7 {
            #[prost(uint64, tag = "7")]
            Epochnum(u64),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof9 {
            #[prost(uint32, tag = "9")]
            Numtxs(u32),
        }
    }
}
/// Used in database "shardStructure"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoShardingStructure {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, repeated, tag = "2")]
    pub shards: ::prost::alloc::vec::Vec<proto_sharding_structure::Shard>,
}
/// Nested message and enum types in `ProtoShardingStructure`.
pub mod proto_sharding_structure {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Member {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "2")]
        pub peerinfo: ::core::option::Option<super::ByteArray>,
        #[prost(oneof = "member::Oneof3", tags = "3")]
        pub oneof3: ::core::option::Option<member::Oneof3>,
    }
    /// Nested message and enum types in `Member`.
    pub mod member {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof3 {
            #[prost(uint32, tag = "3")]
            Reputation(u32),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Shard {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, repeated, tag = "1")]
        pub members: ::prost::alloc::vec::Vec<Member>,
    }
}
/// Used in database "txBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMbInfo {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "1")]
    pub mbhash: ::prost::alloc::vec::Vec<u8>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "2")]
    pub txroot: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "proto_mb_info::Oneof3", tags = "3")]
    pub oneof3: ::core::option::Option<proto_mb_info::Oneof3>,
}
/// Nested message and enum types in `ProtoMbInfo`.
pub mod proto_mb_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof3 {
        #[prost(uint32, tag = "3")]
        Shardid(u32),
    }
}
/// Used in database "txBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTxBlock {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<proto_tx_block::TxBlockHeader>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, repeated, tag = "2")]
    pub mbinfos: ::prost::alloc::vec::Vec<ProtoMbInfo>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "3")]
    pub blockbase: ::core::option::Option<ProtoBlockBase>,
}
/// Nested message and enum types in `ProtoTxBlock`.
pub mod proto_tx_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TxBlockHashSet {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "1")]
        pub stateroothash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "2")]
        pub statedeltahash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "3")]
        pub mbinfohash: ::prost::alloc::vec::Vec<u8>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TxBlockHeader {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub blockheaderbase: ::core::option::Option<super::ProtoBlockHeaderBase>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(uint64, tag = "2")]
        pub gaslimit: u64,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "4")]
        pub rewards: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "5")]
        pub prevhash: ::prost::alloc::vec::Vec<u8>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "7")]
        pub hash: ::core::option::Option<TxBlockHashSet>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "9")]
        pub minerpubkey: ::core::option::Option<super::ByteArray>,
        #[prost(oneof = "tx_block_header::Oneof3", tags = "3")]
        pub oneof3: ::core::option::Option<tx_block_header::Oneof3>,
        #[prost(oneof = "tx_block_header::Oneof6", tags = "6")]
        pub oneof6: ::core::option::Option<tx_block_header::Oneof6>,
        #[prost(oneof = "tx_block_header::Oneof8", tags = "8")]
        pub oneof8: ::core::option::Option<tx_block_header::Oneof8>,
        #[prost(oneof = "tx_block_header::Oneof10", tags = "10")]
        pub oneof10: ::core::option::Option<tx_block_header::Oneof10>,
    }
    /// Nested message and enum types in `TxBlockHeader`.
    pub mod tx_block_header {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof3 {
            #[prost(uint64, tag = "3")]
            Gasused(u64),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof6 {
            #[prost(uint64, tag = "6")]
            Blocknum(u64),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof8 {
            #[prost(uint32, tag = "8")]
            Numtxs(u32),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof10 {
            #[prost(uint64, tag = "10")]
            Dsblocknum(u64),
        }
    }
}
/// Used in database "VCBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoVcBlock {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub header: ::core::option::Option<proto_vc_block::VcBlockHeader>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub blockbase: ::core::option::Option<ProtoBlockBase>,
}
/// Nested message and enum types in `ProtoVCBlock`.
pub mod proto_vc_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct VcBlockHeader {
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "1")]
        pub blockheaderbase: ::core::option::Option<super::ProtoBlockHeaderBase>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(uint64, tag = "2")]
        pub viewchangedsepochno: u64,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(uint64, tag = "3")]
        pub viewchangeepochno: u64,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "5")]
        pub candidateleadernetworkinfo: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, optional, tag = "6")]
        pub candidateleaderpubkey: ::core::option::Option<super::ByteArray>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(message, repeated, tag = "8")]
        pub faultyleaders: ::prost::alloc::vec::Vec<super::ProtoDsNode>,
        /// Added in: v1.0, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "9")]
        pub prevhash: ::prost::alloc::vec::Vec<u8>,
        #[prost(oneof = "vc_block_header::Oneof4", tags = "4")]
        pub oneof4: ::core::option::Option<vc_block_header::Oneof4>,
        #[prost(oneof = "vc_block_header::Oneof7", tags = "7")]
        pub oneof7: ::core::option::Option<vc_block_header::Oneof7>,
    }
    /// Nested message and enum types in `VCBlockHeader`.
    pub mod vc_block_header {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof4 {
            #[prost(uint32, tag = "4")]
            Viewchangestate(u32),
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof7 {
            #[prost(uint32, tag = "7")]
            Vccounter(u32),
        }
    }
}
/// Used in database "diagnosticNodes"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDiagnosticDataNodes {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub shards: ::core::option::Option<ProtoShardingStructure>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub dscommittee: ::core::option::Option<ProtoDsCommittee>,
}
/// Used in database "diagnosticCoinb"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDiagnosticDataCoinbase {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub nodecount: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub sigcount: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "3")]
    pub lookupcount: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "4")]
    pub totalreward: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "5")]
    pub basereward: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "6")]
    pub baserewardeach: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "7")]
    pub lookupreward: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "8")]
    pub rewardeachlookup: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "9")]
    pub nodereward: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "10")]
    pub rewardeach: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "11")]
    pub balanceleft: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "12")]
    pub luckydrawwinnerkey: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "13")]
    pub luckydrawwinneraddr: ::prost::alloc::vec::Vec<u8>,
}
/// Used in database "minerInfoDSComm"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMinerInfoDsComm {
    #[prost(message, repeated, tag = "1")]
    pub dsnodes: ::prost::alloc::vec::Vec<proto_miner_info_ds_comm::Node>,
    /// Add new members here
    #[prost(message, repeated, tag = "2")]
    pub dsnodesejected: ::prost::alloc::vec::Vec<proto_miner_info_ds_comm::Node>,
}
/// Nested message and enum types in `ProtoMinerInfoDSComm`.
pub mod proto_miner_info_ds_comm {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Node {
        #[prost(message, optional, tag = "1")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
    }
}
/// Used in database "minerInfoShards"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMinerInfoShards {
    /// Add new members here
    #[prost(message, repeated, tag = "1")]
    pub shards: ::prost::alloc::vec::Vec<proto_miner_info_shards::Shard>,
}
/// Nested message and enum types in `ProtoMinerInfoShards`.
pub mod proto_miner_info_shards {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Node {
        #[prost(message, optional, tag = "1")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Shard {
        #[prost(uint32, tag = "1")]
        pub shardsize: u32,
        #[prost(message, repeated, tag = "2")]
        pub shardnodes: ::prost::alloc::vec::Vec<Node>,
    }
}
/// Used in database "microBlocks"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoMicroBlockKey {
    #[prost(uint64, tag = "1")]
    pub epochnum: u64,
    #[prost(uint32, tag = "2")]
    pub shardid: u32,
}
/// Used in database "txEpochs"
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTxEpoch {
    #[prost(uint64, tag = "1")]
    pub epochnum: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoAccountBase {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "2")]
    pub balance: ::core::option::Option<ByteArray>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "4")]
    pub codehash: ::prost::alloc::vec::Vec<u8>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "5")]
    pub storageroot: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "proto_account_base::Oneof3", tags = "3")]
    pub oneof3: ::core::option::Option<proto_account_base::Oneof3>,
}
/// Nested message and enum types in `ProtoAccountBase`.
pub mod proto_account_base {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof3 {
        #[prost(uint64, tag = "3")]
        Nonce(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoAccount {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(message, optional, tag = "1")]
    pub base: ::core::option::Option<ProtoAccountBase>,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "2")]
    pub code: ::prost::alloc::vec::Vec<u8>,
    /// For account delta (false=neg, true=pos) // Added in: v1.0, Deprecated in: N/A
    #[prost(bool, tag = "4")]
    pub numbersign: bool,
    /// Added in: v1.1, Deprecated in: N/A
    #[prost(message, repeated, tag = "5")]
    pub storage2: ::prost::alloc::vec::Vec<proto_account::StorageData2>,
    /// Added in: v1.1, Deprecated in: N/A
    #[prost(string, repeated, tag = "6")]
    pub todelete: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Added in: v1.1, Deprecated in: N/A
    #[prost(bytes = "vec", tag = "7")]
    pub initdata: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `ProtoAccount`.
pub mod proto_account {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StorageData2 {
        /// Added in: v1.1, Deprecated in: N/A
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        /// Added in: v1.1, Deprecated in: N/A
        #[prost(bytes = "vec", tag = "2")]
        pub data: ::prost::alloc::vec::Vec<u8>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoStateIndex {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub index: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoStateData {
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(uint32, tag = "1")]
    pub version: u32,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(string, tag = "2")]
    pub vname: ::prost::alloc::string::String,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(bool, tag = "3")]
    pub ismutable: bool,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(string, tag = "4")]
    pub r#type: ::prost::alloc::string::String,
    /// Added in: v1.0, Deprecated in: N/A
    #[prost(string, tag = "5")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoAccountStore {
    #[prost(message, repeated, tag = "3")]
    pub entries: ::prost::alloc::vec::Vec<proto_account_store::AddressAccount>,
}
/// Nested message and enum types in `ProtoAccountStore`.
pub mod proto_account_store {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AddressAccount {
        #[prost(bytes = "vec", tag = "1")]
        pub address: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, optional, tag = "2")]
        pub account: ::core::option::Option<super::ProtoAccount>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoPeer {
    #[prost(message, optional, tag = "1")]
    pub ipaddress: ::core::option::Option<ByteArray>,
    #[prost(oneof = "proto_peer::Oneof2", tags = "2")]
    pub oneof2: ::core::option::Option<proto_peer::Oneof2>,
}
/// Nested message and enum types in `ProtoPeer`.
pub mod proto_peer {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof2 {
        #[prost(uint32, tag = "2")]
        Listenporthost(u32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoPoWSolution {
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub result: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub mixhash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub gasprice: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "6")]
    pub govdata: ::core::option::Option<GovernanceData>,
    #[prost(bytes = "vec", tag = "7")]
    pub extradata: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "proto_po_w_solution::Oneof4", tags = "4")]
    pub oneof4: ::core::option::Option<proto_po_w_solution::Oneof4>,
}
/// Nested message and enum types in `ProtoPoWSolution`.
pub mod proto_po_w_solution {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof4 {
        #[prost(uint32, tag = "4")]
        Lookupid(u32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoCommittee {
    #[prost(message, repeated, tag = "1")]
    pub members: ::prost::alloc::vec::Vec<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoShardingStructureWithPoWSolns {
    #[prost(message, repeated, tag = "1")]
    pub shards: ::prost::alloc::vec::Vec<
        proto_sharding_structure_with_po_w_solns::Shard,
    >,
}
/// Nested message and enum types in `ProtoShardingStructureWithPoWSolns`.
pub mod proto_sharding_structure_with_po_w_solns {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Member {
        #[prost(message, optional, tag = "1")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "2")]
        pub peerinfo: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "4")]
        pub powsoln: ::core::option::Option<super::ProtoPoWSolution>,
        #[prost(oneof = "member::Oneof3", tags = "3")]
        pub oneof3: ::core::option::Option<member::Oneof3>,
    }
    /// Nested message and enum types in `Member`.
    pub mod member {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Oneof3 {
            #[prost(uint32, tag = "3")]
            Reputation(u32),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Shard {
        #[prost(message, repeated, tag = "1")]
        pub members: ::prost::alloc::vec::Vec<Member>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDsWinnerPoW {
    #[prost(message, optional, tag = "1")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "2")]
    pub powsoln: ::core::option::Option<ProtoPoWSolution>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTransactionCoreInfo {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub toaddr: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub senderpubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "5")]
    pub amount: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "6")]
    pub gasprice: ::core::option::Option<ByteArray>,
    #[prost(uint64, tag = "7")]
    pub gaslimit: u64,
    #[prost(message, repeated, tag = "10")]
    pub access_list: ::prost::alloc::vec::Vec<AccessListItem>,
    #[prost(message, optional, tag = "11")]
    pub maxpriorityfeepergas: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "12")]
    pub maxfeepergas: ::core::option::Option<ByteArray>,
    #[prost(oneof = "proto_transaction_core_info::Oneof2", tags = "2")]
    pub oneof2: ::core::option::Option<proto_transaction_core_info::Oneof2>,
    #[prost(oneof = "proto_transaction_core_info::Oneof8", tags = "8")]
    pub oneof8: ::core::option::Option<proto_transaction_core_info::Oneof8>,
    #[prost(oneof = "proto_transaction_core_info::Oneof9", tags = "9")]
    pub oneof9: ::core::option::Option<proto_transaction_core_info::Oneof9>,
}
/// Nested message and enum types in `ProtoTransactionCoreInfo`.
pub mod proto_transaction_core_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof2 {
        #[prost(uint64, tag = "2")]
        Nonce(u64),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof8 {
        #[prost(bytes, tag = "8")]
        Code(::prost::alloc::vec::Vec<u8>),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof9 {
        #[prost(bytes, tag = "9")]
        Data(::prost::alloc::vec::Vec<u8>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessListItem {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub storagekeys: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTransaction {
    #[prost(bytes = "vec", tag = "1")]
    pub tranid: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<ProtoTransactionCoreInfo>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTxnFileOffset {
    #[prost(uint32, repeated, tag = "1")]
    pub offsetinfile: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTransactionArray {
    #[prost(message, repeated, tag = "1")]
    pub transactions: ::prost::alloc::vec::Vec<ProtoTransaction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTransactionReceipt {
    #[prost(bytes = "vec", tag = "1")]
    pub receipt: ::prost::alloc::vec::Vec<u8>,
    #[prost(oneof = "proto_transaction_receipt::Oneof2", tags = "2")]
    pub oneof2: ::core::option::Option<proto_transaction_receipt::Oneof2>,
}
/// Nested message and enum types in `ProtoTransactionReceipt`.
pub mod proto_transaction_receipt {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Oneof2 {
        #[prost(uint64, tag = "2")]
        Cumgas(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoTransactionWithReceipt {
    #[prost(message, optional, tag = "1")]
    pub transaction: ::core::option::Option<ProtoTransaction>,
    #[prost(message, optional, tag = "2")]
    pub receipt: ::core::option::Option<ProtoTransactionReceipt>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoBloomFilter {
    #[prost(uint32, repeated, tag = "1")]
    pub salt: ::prost::alloc::vec::Vec<u32>,
    #[prost(bytes = "vec", tag = "2")]
    pub bittable: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "3")]
    pub saltcount: u32,
    #[prost(uint64, tag = "4")]
    pub tablesize: u64,
    #[prost(uint64, tag = "5")]
    pub projectedelementcount: u64,
    #[prost(uint64, tag = "6")]
    pub insertedelementcount: u64,
    #[prost(uint64, tag = "7")]
    pub randomseed: u64,
    #[prost(double, tag = "8")]
    pub probability: f64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoSwInfo {
    #[prost(uint32, tag = "1")]
    pub zilliqamajorversion: u32,
    #[prost(uint32, tag = "2")]
    pub zilliqaminorversion: u32,
    #[prost(uint32, tag = "3")]
    pub zilliqafixversion: u32,
    #[prost(uint64, tag = "4")]
    pub zilliqaupgradeds: u64,
    #[prost(uint32, tag = "5")]
    pub zilliqacommit: u32,
    #[prost(uint32, tag = "6")]
    pub scillamajorversion: u32,
    #[prost(uint32, tag = "7")]
    pub scillaminorversion: u32,
    #[prost(uint32, tag = "8")]
    pub scillafixversion: u32,
    #[prost(uint64, tag = "9")]
    pub scillaupgradeds: u64,
    #[prost(uint32, tag = "10")]
    pub scillacommit: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoSingleDirectoryBlock {
    #[prost(oneof = "proto_single_directory_block::Directoryblock", tags = "1, 2")]
    pub directoryblock: ::core::option::Option<
        proto_single_directory_block::Directoryblock,
    >,
}
/// Nested message and enum types in `ProtoSingleDirectoryBlock`.
pub mod proto_single_directory_block {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Directoryblock {
        #[prost(message, tag = "1")]
        Dsblock(super::ProtoDsBlock),
        #[prost(message, tag = "2")]
        Vcblock(super::ProtoVcBlock),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PmHello {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<pm_hello::Data>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `PMHello`.
pub mod pm_hello {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, optional, tag = "1")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
        #[prost(uint32, tag = "2")]
        pub listenport: u32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GovernanceData {
    #[prost(uint32, tag = "1")]
    pub proposalid: u32,
    #[prost(uint32, tag = "2")]
    pub votevalue: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsPoWSubmission {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ds_po_w_submission::Data>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `DSPoWSubmission`.
pub mod ds_po_w_submission {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknumber: u64,
        /// only LSB used
        #[prost(uint32, tag = "2")]
        pub difficultylevel: u32,
        #[prost(message, optional, tag = "3")]
        pub submitterpeer: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "4")]
        pub submitterpub_key: ::core::option::Option<super::ByteArray>,
        #[prost(uint64, tag = "5")]
        pub nonce: u64,
        #[prost(string, tag = "6")]
        pub resultinghash: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub mixhash: ::prost::alloc::string::String,
        #[prost(uint32, tag = "8")]
        pub lookupid: u32,
        #[prost(message, optional, tag = "9")]
        pub gasprice: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "10")]
        pub govdata: ::core::option::Option<super::GovernanceData>,
        #[prost(string, tag = "11")]
        pub version: ::prost::alloc::string::String,
        #[prost(bytes = "vec", tag = "12")]
        pub extra_data: ::prost::alloc::vec::Vec<u8>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsPoWPacketSubmission {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ds_po_w_packet_submission::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `DSPoWPacketSubmission`.
pub mod ds_po_w_packet_submission {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub ds_pow_submissions: ::prost::alloc::vec::Vec<super::DsPoWSubmission>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsMicroBlockSubmission {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ds_micro_block_submission::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `DSMicroBlockSubmission`.
pub mod ds_micro_block_submission {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        /// only LSB used
        #[prost(uint32, tag = "1")]
        pub microblocktype: u32,
        #[prost(uint64, tag = "2")]
        pub epochnumber: u64,
        #[prost(message, repeated, tag = "3")]
        pub microblocks: ::prost::alloc::vec::Vec<super::ProtoMicroBlock>,
        #[prost(bytes = "vec", repeated, tag = "4")]
        pub statedeltas: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsdsBlockAnnouncement {
    #[prost(message, optional, tag = "1")]
    pub dsblock: ::core::option::Option<ProtoDsBlock>,
    #[prost(message, optional, tag = "2")]
    pub sharding: ::core::option::Option<ProtoShardingStructureWithPoWSolns>,
    #[prost(message, repeated, tag = "3")]
    pub dswinnerpows: ::prost::alloc::vec::Vec<ProtoDsWinnerPoW>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsFinalBlockAnnouncement {
    #[prost(message, optional, tag = "1")]
    pub txblock: ::core::option::Option<ProtoTxBlock>,
    #[prost(message, optional, tag = "2")]
    pub microblock: ::core::option::Option<ProtoMicroBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsvcBlockAnnouncement {
    #[prost(message, optional, tag = "1")]
    pub vcblock: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsMissingMicroBlocksErrorMsg {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub mbhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, tag = "2")]
    pub epochnum: u64,
    #[prost(uint32, tag = "3")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeDsBlock {
    #[prost(uint32, tag = "1")]
    pub shardid: u32,
    #[prost(message, optional, tag = "2")]
    pub dsblock: ::core::option::Option<ProtoDsBlock>,
    #[prost(message, repeated, tag = "3")]
    pub vcblocks: ::prost::alloc::vec::Vec<ProtoVcBlock>,
    #[prost(message, optional, tag = "4")]
    pub sharding: ::core::option::Option<ProtoShardingStructure>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeFinalBlock {
    #[prost(uint64, tag = "1")]
    pub dsblocknumber: u64,
    #[prost(uint32, tag = "2")]
    pub consensusid: u32,
    #[prost(message, optional, tag = "3")]
    pub txblock: ::core::option::Option<ProtoTxBlock>,
    #[prost(bytes = "vec", tag = "4")]
    pub statedelta: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, repeated, tag = "5")]
    pub shardids: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeVcFinalBlock {
    #[prost(uint64, tag = "1")]
    pub dsblocknumber: u64,
    #[prost(uint32, tag = "2")]
    pub consensusid: u32,
    #[prost(message, optional, tag = "3")]
    pub txblock: ::core::option::Option<ProtoTxBlock>,
    #[prost(bytes = "vec", tag = "4")]
    pub statedelta: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "5")]
    pub vcblocks: ::prost::alloc::vec::Vec<ProtoVcBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMBnForwardTransaction {
    #[prost(message, optional, tag = "1")]
    pub microblock: ::core::option::Option<ProtoMicroBlock>,
    #[prost(message, repeated, tag = "2")]
    pub txnswithreceipt: ::prost::alloc::vec::Vec<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodePendingTxn {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<node_pending_txn::Data>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `NodePendingTxn`.
pub mod node_pending_txn {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub hashcodepair: ::prost::alloc::vec::Vec<data::Pair>,
        #[prost(uint64, tag = "2")]
        pub epochnumber: u64,
        #[prost(uint32, tag = "3")]
        pub shardid: u32,
        #[prost(message, optional, tag = "4")]
        pub pubkey: ::core::option::Option<super::ByteArray>,
        #[prost(bytes = "vec", tag = "5")]
        pub txnlisthash: ::prost::alloc::vec::Vec<u8>,
    }
    /// Nested message and enum types in `Data`.
    pub mod data {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Pair {
            #[prost(bytes = "vec", tag = "1")]
            pub txnhash: ::prost::alloc::vec::Vec<u8>,
            #[prost(uint32, tag = "2")]
            pub code: u32,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeVcBlock {
    #[prost(message, optional, tag = "1")]
    pub vcblock: ::core::option::Option<ProtoVcBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeForwardTxnBlock {
    #[prost(uint64, tag = "1")]
    pub epochnumber: u64,
    #[prost(uint64, tag = "2")]
    pub dsblocknum: u64,
    #[prost(uint32, tag = "3")]
    pub shardid: u32,
    #[prost(message, optional, tag = "4")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, repeated, tag = "5")]
    pub transactions: ::prost::alloc::vec::Vec<ProtoTransaction>,
    #[prost(message, optional, tag = "6")]
    pub signature: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMicroBlockAnnouncement {
    #[prost(message, optional, tag = "1")]
    pub microblock: ::core::option::Option<ProtoMicroBlock>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeMissingTxnsErrorMsg {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub txnhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint64, tag = "2")]
    pub epochnum: u64,
    #[prost(uint32, tag = "3")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGetVersion {
    #[prost(uint32, tag = "1")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeSetVersion {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetSeedPeers {
    #[prost(uint32, tag = "1")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetSeedPeers {
    #[prost(message, repeated, tag = "1")]
    pub candidateseeds: ::prost::alloc::vec::Vec<ByteArray>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// From normal node to lookup nodes.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDsInfoFromSeed {
    #[prost(uint32, tag = "1")]
    pub listenport: u32,
    #[prost(bool, tag = "2")]
    pub initialds: bool,
}
/// From DS leader to lookup nodes and from lookup nodes to normal nodes.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetDsInfoFromSeed {
    #[prost(message, optional, tag = "1")]
    pub dscommittee: ::core::option::Option<ProtoDsCommittee>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
    #[prost(bool, tag = "4")]
    pub initialds: bool,
}
/// From new join lookup node or new join normal node to existing lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDsBlockFromSeed {
    #[prost(uint64, tag = "1")]
    pub lowblocknum: u64,
    #[prost(uint64, tag = "2")]
    pub highblocknum: u64,
    #[prost(uint32, tag = "3")]
    pub listenport: u32,
    #[prost(bool, tag = "4")]
    pub includeminerinfo: bool,
}
/// From lookup nodes to new join lookup node or new join normal node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetDsBlockFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_ds_block_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetDSBlockFromSeed`.
pub mod lookup_set_ds_block_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub lowblocknum: u64,
        #[prost(uint64, tag = "2")]
        pub highblocknum: u64,
        #[prost(message, repeated, tag = "3")]
        pub dsblocks: ::prost::alloc::vec::Vec<super::ProtoDsBlock>,
    }
}
/// From lookup nodes to new join lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetMinerInfoFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_miner_info_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetMinerInfoFromSeed`.
pub mod lookup_set_miner_info_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MinerInfo {
        #[prost(message, optional, tag = "1")]
        pub minerinfodscomm: ::core::option::Option<super::ProtoMinerInfoDsComm>,
        #[prost(message, optional, tag = "2")]
        pub minerinfoshards: ::core::option::Option<super::ProtoMinerInfoShards>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(map = "uint64, message", tag = "1")]
        pub minerinfoperds: ::std::collections::HashMap<u64, MinerInfo>,
    }
}
/// From new join lookup node or new join normal node to existing lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetTxBlockFromSeed {
    #[prost(uint64, tag = "1")]
    pub lowblocknum: u64,
    #[prost(uint64, tag = "2")]
    pub highblocknum: u64,
    #[prost(uint32, tag = "3")]
    pub listenport: u32,
}
/// From lookup nodes to new join lookup node or new join normal node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetTxBlockFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_tx_block_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetTxBlockFromSeed`.
pub mod lookup_set_tx_block_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub lowblocknum: u64,
        #[prost(uint64, tag = "2")]
        pub highblocknum: u64,
        #[prost(message, repeated, tag = "3")]
        pub txblocks: ::prost::alloc::vec::Vec<super::ProtoTxBlock>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetStateDeltaFromSeed {
    #[prost(uint64, tag = "1")]
    pub blocknum: u64,
    #[prost(uint32, tag = "2")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetStateDeltasFromSeed {
    #[prost(uint64, tag = "1")]
    pub lowblocknum: u64,
    #[prost(uint64, tag = "2")]
    pub highblocknum: u64,
    #[prost(uint32, tag = "3")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetStateDeltaFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_state_delta_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetStateDeltaFromSeed`.
pub mod lookup_set_state_delta_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknum: u64,
        #[prost(bytes = "vec", tag = "2")]
        pub statedelta: ::prost::alloc::vec::Vec<u8>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetStateDeltasFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_state_deltas_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetStateDeltasFromSeed`.
pub mod lookup_set_state_deltas_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub lowblocknum: u64,
        #[prost(uint64, tag = "2")]
        pub highblocknum: u64,
        #[prost(bytes = "vec", repeated, tag = "3")]
        pub statedeltas: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
}
/// msgtype is used to prevent replay attacks
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetLookupOffline {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_lookup_offline::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetLookupOffline`.
pub mod lookup_set_lookup_offline {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        /// Only LSB used
        #[prost(uint32, tag = "1")]
        pub msgtype: u32,
        #[prost(uint32, tag = "2")]
        pub listenport: u32,
    }
}
/// msgtype and blocknumber are used to prevent replay attacks
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetLookupOnline {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_lookup_online::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetLookupOnline`.
pub mod lookup_set_lookup_online {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        /// Only LSB used
        #[prost(uint32, tag = "1")]
        pub msgtype: u32,
        #[prost(uint32, tag = "2")]
        pub listenport: u32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetOfflineLookups {
    #[prost(uint32, tag = "1")]
    pub listenport: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetOfflineLookups {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<ByteArray>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// From archival node to lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetShardsFromSeed {
    #[prost(uint32, tag = "1")]
    pub listenport: u32,
}
/// From lookup node to archival node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetShardsFromSeed {
    #[prost(message, optional, tag = "1")]
    pub sharding: ::core::option::Option<ProtoShardingStructure>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetMicroBlockFromLookup {
    #[prost(uint32, tag = "1")]
    pub portno: u32,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub mbhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetMicroBlockFromLookup {
    #[prost(message, repeated, tag = "1")]
    pub microblocks: ::prost::alloc::vec::Vec<ProtoMicroBlock>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetMicroBlockFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_micro_block_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetMicroBlockFromL2l`.
pub mod lookup_get_micro_block_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, tag = "1")]
        pub portno: u32,
        #[prost(bytes = "vec", repeated, tag = "2")]
        pub mbhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupForwardTxnsFromSeed {
    #[prost(message, optional, tag = "1")]
    pub transactions: ::core::option::Option<ProtoTransactionArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetTxnsFromLookup {
    #[prost(uint32, tag = "1")]
    pub portno: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub mbhash: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub txnhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetTxnsFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_txns_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetTxnsFromL2l`.
pub mod lookup_get_txns_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, tag = "1")]
        pub portno: u32,
        #[prost(bytes = "vec", tag = "2")]
        pub mbhash: ::prost::alloc::vec::Vec<u8>,
        #[prost(bytes = "vec", repeated, tag = "3")]
        pub txnhashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetTxnsFromLookup {
    #[prost(bytes = "vec", tag = "1")]
    pub mbhash: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub transactions: ::prost::alloc::vec::Vec<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "4")]
    pub signature: ::core::option::Option<ByteArray>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDirectoryBlocksFromSeed {
    #[prost(uint32, tag = "1")]
    pub portno: u32,
    #[prost(uint64, tag = "2")]
    pub indexnum: u64,
    #[prost(bool, tag = "3")]
    pub includeminerinfo: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetDirectoryBlocksFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_directory_blocks_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetDirectoryBlocksFromSeed`.
pub mod lookup_set_directory_blocks_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub indexnum: u64,
        #[prost(message, repeated, tag = "2")]
        pub dirblocks: ::prost::alloc::vec::Vec<super::ProtoSingleDirectoryBlock>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusAnnouncement {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_announcement::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    /// The signature of the consensus info
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "9")]
    pub finalsignature: ::core::option::Option<ByteArray>,
    #[prost(oneof = "consensus_announcement::Announcement", tags = "4, 5, 6, 7")]
    pub announcement: ::core::option::Option<consensus_announcement::Announcement>,
}
/// Nested message and enum types in `ConsensusAnnouncement`.
pub mod consensus_announcement {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub leaderid: u32,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Announcement {
        #[prost(message, tag = "4")]
        Dsblock(super::DsdsBlockAnnouncement),
        #[prost(message, tag = "5")]
        Microblock(super::NodeMicroBlockAnnouncement),
        #[prost(message, tag = "6")]
        Finalblock(super::DsFinalBlockAnnouncement),
        #[prost(message, tag = "7")]
        Vcblock(super::DsvcBlockAnnouncement),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommit {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_commit::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusCommit`.
pub mod consensus_commit {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CommitInfo {
        #[prost(message, optional, tag = "1")]
        pub commitpoint: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "2")]
        pub commitpointhash: ::core::option::Option<super::ByteArray>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub backupid: u32,
        #[prost(message, repeated, tag = "5")]
        pub commitinfo: ::prost::alloc::vec::Vec<CommitInfo>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusChallenge {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_challenge::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusChallenge`.
pub mod consensus_challenge {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubsetInfo {
        #[prost(message, optional, tag = "1")]
        pub aggregatedcommit: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "2")]
        pub aggregatedkey: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "3")]
        pub challenge: ::core::option::Option<super::ByteArray>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub leaderid: u32,
        #[prost(message, repeated, tag = "5")]
        pub subsetinfo: ::prost::alloc::vec::Vec<SubsetInfo>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusResponse {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_response::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusResponse`.
pub mod consensus_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubsetInfo {
        #[prost(message, optional, tag = "1")]
        pub response: ::core::option::Option<super::ByteArray>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 byte used
        #[prost(uint32, tag = "4")]
        pub backupid: u32,
        #[prost(message, repeated, tag = "5")]
        pub subsetinfo: ::prost::alloc::vec::Vec<SubsetInfo>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCollectiveSig {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_collective_sig::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
    #[prost(bytes = "vec", tag = "4")]
    pub newannouncement: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub finalsignature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusCollectiveSig`.
pub mod consensus_collective_sig {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub leaderid: u32,
        #[prost(message, optional, tag = "5")]
        pub collectivesig: ::core::option::Option<super::ByteArray>,
        #[prost(bool, repeated, tag = "6")]
        pub bitmap: ::prost::alloc::vec::Vec<bool>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusCommitFailure {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<consensus_commit_failure::ConsensusInfo>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusCommitFailure`.
pub mod consensus_commit_failure {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub backupid: u32,
        #[prost(bytes = "vec", tag = "5")]
        pub errormsg: ::prost::alloc::vec::Vec<u8>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsensusConsensusFailure {
    #[prost(message, optional, tag = "1")]
    pub consensusinfo: ::core::option::Option<
        consensus_consensus_failure::ConsensusInfo,
    >,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `ConsensusConsensusFailure`.
pub mod consensus_consensus_failure {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConsensusInfo {
        #[prost(uint32, tag = "1")]
        pub consensusid: u32,
        #[prost(uint64, tag = "2")]
        pub blocknumber: u64,
        /// 32 bytes
        #[prost(bytes = "vec", tag = "3")]
        pub blockhash: ::prost::alloc::vec::Vec<u8>,
        /// only lower 2 bytes used
        #[prost(uint32, tag = "4")]
        pub leaderid: u32,
    }
}
/// From node undergoing vc pre check to fetch latest blocks
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDsTxBlockFromSeed {
    #[prost(uint64, tag = "1")]
    pub dslowblocknum: u64,
    #[prost(uint64, tag = "2")]
    pub dshighblocknum: u64,
    #[prost(uint64, tag = "3")]
    pub txlowblocknum: u64,
    #[prost(uint64, tag = "4")]
    pub txhighblocknum: u64,
    #[prost(uint32, tag = "5")]
    pub listenport: u32,
}
/// From lookup nodes to node under going vc pre check
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VcNodeSetDsTxBlockFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<vc_node_set_ds_tx_block_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `VCNodeSetDSTxBlockFromSeed`.
pub mod vc_node_set_ds_tx_block_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub dsblocks: ::prost::alloc::vec::Vec<super::ProtoDsBlock>,
        #[prost(message, repeated, tag = "2")]
        pub txblocks: ::prost::alloc::vec::Vec<super::ProtoTxBlock>,
    }
}
/// From shard node to lookup/dsCommittee. New shard node network info.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeSetShardNodeNetworkInfoUpdate {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<node_set_shard_node_network_info_update::Data>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `NodeSetShardNodeNetworkInfoUpdate`.
pub mod node_set_shard_node_network_info_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub dsepochnumber: u64,
        #[prost(message, optional, tag = "2")]
        pub shardnodepubkey: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "3")]
        pub shardnodenewnetworkinfo: ::core::option::Option<super::ProtoPeer>,
        #[prost(uint64, tag = "4")]
        pub timestamp: u64,
    }
}
/// From DS Guard to lookup. New DS guard node network info.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DsLookupSetDsGuardNetworkInfoUpdate {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<ds_lookup_set_ds_guard_network_info_update::Data>,
    #[prost(message, optional, tag = "2")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `DSLookupSetDSGuardNetworkInfoUpdate`.
pub mod ds_lookup_set_ds_guard_network_info_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub dsepochnumber: u64,
        #[prost(message, optional, tag = "2")]
        pub dsguardpubkey: ::core::option::Option<super::ByteArray>,
        #[prost(message, optional, tag = "3")]
        pub dsguardnewnetworkinfo: ::core::option::Option<super::ProtoPeer>,
        #[prost(uint64, tag = "4")]
        pub timestamp: u64,
    }
}
/// To update shard node of guard node's network info change
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGetGuardNodeNetworkInfoUpdate {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<node_get_guard_node_network_info_update::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `NodeGetGuardNodeNetworkInfoUpdate`.
pub mod node_get_guard_node_network_info_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, tag = "1")]
        pub portno: u32,
        #[prost(uint64, tag = "2")]
        pub dsepochnumber: u64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoDsGuardUpdateStruct {
    #[prost(message, optional, tag = "1")]
    pub dsguardpubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "2")]
    pub dsguardnewnetworkinfo: ::core::option::Option<ProtoPeer>,
    #[prost(uint64, tag = "3")]
    pub timestamp: u64,
}
/// From sending New DS guard node network info to requesing shard node
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeSetGuardNodeNetworkInfoUpdate {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<node_set_guard_node_network_info_update::Data>,
    #[prost(message, optional, tag = "2")]
    pub lookuppubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `NodeSetGuardNodeNetworkInfoUpdate`.
pub mod node_set_guard_node_network_info_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub dsguardupdatestruct: ::prost::alloc::vec::Vec<
            super::ProtoDsGuardUpdateStruct,
        >,
    }
}
/// For removing sender from local blacklist
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeRemoveFromBlacklist {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<node_remove_from_blacklist::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `NodeRemoveFromBlacklist`.
pub mod node_remove_from_blacklist {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, optional, tag = "1")]
        pub ip_address: ::core::option::Option<super::ByteArray>,
        #[prost(uint64, tag = "2")]
        pub dsepochnumber: u64,
    }
}
/// Holds cosigs and rewards structure for specific shard of specific epoch
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtoCosigsRewardsStructure {
    #[prost(uint64, tag = "1")]
    pub epochnumber: u64,
    #[prost(int32, tag = "2")]
    pub shardid: i32,
    #[prost(message, optional, tag = "3")]
    pub blockbase: ::core::option::Option<ProtoBlockBase>,
    #[prost(message, optional, tag = "4")]
    pub rewards: ::core::option::Option<ByteArray>,
}
/// From DS node for fetching cosig/rewards from Lookup
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetCosigsRewardsFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_cosigs_rewards_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetCosigsRewardsFromSeed`.
pub mod lookup_get_cosigs_rewards_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, tag = "1")]
        pub portno: u32,
        #[prost(uint64, tag = "2")]
        pub epochnumber: u64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDsLeaderTxnPool {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_ds_leader_txn_pool::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetDSLeaderTxnPool`.
pub mod lookup_get_ds_leader_txn_pool {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint32, tag = "1")]
        pub portno: u32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetDsLeaderTxnPool {
    #[prost(message, optional, tag = "1")]
    pub ds_leader_txn_pool: ::core::option::Option<ProtoTransactionArray>,
}
/// Lookup set cosigs/rewards for ds node
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupSetCosigsRewardsFromSeed {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_set_cosigs_rewards_from_seed::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupSetCosigsRewardsFromSeed`.
pub mod lookup_set_cosigs_rewards_from_seed {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(message, repeated, tag = "1")]
        pub cosigsrewards: ::prost::alloc::vec::Vec<super::ProtoCosigsRewardsStructure>,
    }
}
/// From seed node to level2lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetVcFinalBlockFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_vc_final_block_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetVCFinalBlockFromL2l`.
pub mod lookup_get_vc_final_block_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknum: u64,
        #[prost(message, optional, tag = "2")]
        pub sender: ::core::option::Option<super::ProtoPeer>,
    }
}
/// From seed node to level2lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetDsBlockFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_ds_block_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetDSBlockFromL2l`.
pub mod lookup_get_ds_block_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknum: u64,
        #[prost(message, optional, tag = "2")]
        pub sender: ::core::option::Option<super::ProtoPeer>,
    }
}
/// From seed node to level2lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetMBnForwardTxnFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_m_bn_forward_txn_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetMBnForwardTxnFromL2l`.
pub mod lookup_get_m_bn_forward_txn_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknum: u64,
        #[prost(uint32, tag = "2")]
        pub shard_id: u32,
        #[prost(message, optional, tag = "3")]
        pub sender: ::core::option::Option<super::ProtoPeer>,
    }
}
/// From seed node to level2lookup node.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupGetPendingTxnFromL2l {
    #[prost(message, optional, tag = "1")]
    pub data: ::core::option::Option<lookup_get_pending_txn_from_l2l::Data>,
    #[prost(message, optional, tag = "2")]
    pub pubkey: ::core::option::Option<ByteArray>,
    #[prost(message, optional, tag = "3")]
    pub signature: ::core::option::Option<ByteArray>,
}
/// Nested message and enum types in `LookupGetPendingTxnFromL2l`.
pub mod lookup_get_pending_txn_from_l2l {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Data {
        #[prost(uint64, tag = "1")]
        pub blocknum: u64,
        #[prost(uint32, tag = "2")]
        pub shard_id: u32,
        #[prost(message, optional, tag = "3")]
        pub sender: ::core::option::Option<super::ProtoPeer>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxTraceStoredDisk {
    #[prost(message, repeated, tag = "1")]
    pub items: ::prost::alloc::vec::Vec<ByteArray>,
    #[prost(uint64, tag = "2")]
    pub index: u64,
    #[prost(string, tag = "3")]
    pub tx_trace: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtterscanTrace {
    #[prost(string, tag = "1")]
    pub trace: ::prost::alloc::string::String,
}
/// tx address will map to this and contain all tx hashes
/// associated with that address
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtterscanTraceAddressMapping {
    #[prost(message, repeated, tag = "1")]
    pub hashes: ::prost::alloc::vec::Vec<otterscan_trace_address_mapping::TxHashInfo>,
}
/// Nested message and enum types in `OtterscanTraceAddressMapping`.
pub mod otterscan_trace_address_mapping {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TxHashInfo {
        #[prost(string, tag = "1")]
        pub hash: ::prost::alloc::string::String,
        #[prost(uint64, tag = "2")]
        pub blocknum: u64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OtterscanAddressNonceLookup {
    #[prost(string, tag = "1")]
    pub hash: ::prost::alloc::string::String,
}
